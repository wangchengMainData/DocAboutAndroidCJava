ＪＶＭ
(Java Virtual Machine)
java虚拟机
ＪＶＭ包含：｛
一套字节码指令集
一组寄存器　　　（程序计数器）
一个栈			
一个垃圾回收堆　（java堆/gc堆）
一个存储方法域　（方法区）
｝

JVM原理
（1）jvm是java的核心和基础，在java编译器和os平台之间的虚拟处理器，可在上面执行字节码程序。
（2）java编译器只要面向jvm，生成jvm能理解的字节码文件。java源文件经编译成字节码程序，通过jvm将每条指令翻译成不同的机器码
，通过特定平台运行。

java虚拟机分为五大模块：类装载器子系统，运行时数据区，执行引擎，本地方法接口，垃圾回收模块。

Java程序运行流程：
.java文件通过编译器生成.class文件
.class文件被类加载器ClassLoader加载
类加载器－－》执行引擎(ExcutionEngine)
  |　　　　　　　　　　　　|
　　运行时数据区

运行时数据区即jvm。

jvm内存模型图：
java栈(vm stack) 本地方法栈(native method stack)
		 程序计数器(Program Counter Register)[PC寄存器]
堆(heap)         方法区(Method Area)

a) 程序计数器(PC寄存器)

由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，
因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，
否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，
因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。[无ＯＯＭ情况]

b) java栈

Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、
指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、
**方法返回地址(Return Address)**和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。

c）本地方法栈

本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的

d）堆

Java中的堆是用来存储对象本身的以及数组（数组引用是存放在Java栈中的）。堆是被所有线程共享的，在　JVM中只有一个堆。

e）方法区

与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。
在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。
在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，
对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。

jre,jdk,jvm关系：
jre(java平台，所有的java程序都需要在jre环境下运行)
jdk(编译调试的开发工具包，本身也是java程序，需要jre环境)
jvm(jre的一部分，一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。)


以上jvm模型中出现oom内存不足时的情况：
程序计数器：不会出现

java虚拟机栈：
1.线程请求的栈深度大于虚拟机所允许的深度，爆出StackOverFlowError异常;
2.虚拟机在动态扩展栈时无法申请到足够的内存控件，抛出OOM异常。（在单线程的操作中，无论是由于栈帧太大，还是虚拟机栈空间太小，当栈空间无法分配时，虚拟机抛出的都是StackOverflowError异常，而不会得到OutOfMemoryError异常。而在多线程环境下，则会抛出OutOfMemoryError异常。）

堆：jvm中所管理的内存最大的一块，所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这里分配内存。堆（java heap）时垃圾收集器管理的主要区域，因此也被成为gc堆。
根据Java虚拟机规范的规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。   

方法区：方法区域，又被称为“永久代”，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。


4、谈谈你对JVM的理解？

答： Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。Java编译器只要面向JVM，生成JVM能理解的代码或字节码文件。Java源文件经编译成字节码程序，通过JVM将每一条指令翻译成不同平台机器码，通过特定平台运行。

JVM执行程序的过程 ：I.加载。class文件   ，II.管理并分配内存  ，III.执行垃圾收集

JRE（java运行时环境）由JVM构造的java程序的运行环境 



ＯＯＭ
(Out Of Memery)
2点原因：
分配的少了，比如虚拟机本身可使用的内存太少
应用用的太多并且用完没释放，浪费。　此时会造成内存泄漏或内存溢出


Java语言中，由于存在了　　垃圾自动回收机制　　，所以，我们一般不用去主动释放不用的对象所占的内存，也就是理论上来说，是不会存在“内存泄露”的。
但是，如果　　编码不当　　，比如，　　将某个对象的引用放到了全局的Map中　　，虽然方法结束了，但是由于垃圾回收器会根据对象的引用情况来回收内存，导致该对象不能被及时的回收。如果该种情况出现次数多了，就会导致内存溢出，比如系统中经常使用的缓存机制。Java中的内存泄露，不同于C++中的忘了delete，往往是　　逻辑上的原因泄露。

最常见的OOM情况有以下三种：

    java.lang.OutOfMemoryError: Java heap space ------>java堆内存溢出，此种情况　　最常见　　，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。
    java.lang.OutOfMemoryError: PermGen space ------>java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。
    java.lang.StackOverflowError ------> 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在　死循环　或者　深度递归调用　造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。



垃圾回收机制
ＧＣ。
1、GC是负责回收所有　无任何引用对象　的　内存空间。 注意:　！！！垃圾回收回收的是无任何引用的对象占据的　内存空间　而不是　对象本身　，
2、GC回收机制的两种算法，a、引用计数法  b、可达性分析算法（  这里的可达性，大家可以看基础2 Java对象的什么周期），至于更详细的GC算法介绍，大家可以参考：Java GC机制算法




